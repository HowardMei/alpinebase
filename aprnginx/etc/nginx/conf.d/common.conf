# Common settings from h5bp and https://github.com/nginx-boilerplate/nginx-boilerplate

# Don't tell nginx version to clients.
    server_tokens               off;

# How long to allow each connection to stay idle; longer values are better for SSL, but means that worker connections are tied up longer. (Default: 65)
    reset_timedout_connection   on;
    keepalive_timeout           45;
    keepalive_requests          20;
    keepalive_disable           none;
    client_header_timeout       5;
    client_body_timeout         5;

# Tell Nginx to enable the Nagle buffering algorithm for TCP packets, which collates several smaller packets together into one larger packet,
# thus saving bandwidth at the cost of a nearly imperceptible increase to latency. (removes TCP_NODELAY)
    tcp_nodelay       on;
# Tell Nginx not to send out partial frames; this increases throughput since TCP frames are filled up before being sent out. (adds TCP_CORK)
    tcp_nopush        on;
    types_hash_max_size   8192;
    variables_hash_max_size    1024;
    map_hash_max_size     2048;

# To avoid the error of "could not build the server_names_hash"
    server_names_hash_bucket_size 128;
    server_names_hash_max_size 1024;
# Specifies the maximum accepted body size of a client request, as indicated by the request header Content-Length.
    client_max_body_size      32M;

# The X-Frame-Options header indicates whether a browser should be allowed to render a page within a frame or iframe.
    add_header      X-Frame-Options         SAMEORIGIN;

# MIME type sniffing security protection. There are very few edge cases where you wouldn't want this enabled.
    add_header      X-Content-Type-Options  nosniff;

# The X-XSS-Protection header is used by Internet Explorer version 8+
# The header instructs IE to enable its inbuilt anti-cross-site scripting filter.
    add_header      X-XSS-Protection        "1; mode=block";
# Force the latest IE version
    add_header      "X-UA-Compatible"       "IE=Edge";
# Gzip may encounter issues in IE6. This is obsolete nowdays, but maybe useful in some cases.
    gzip_disable    "msie6";
    msie_padding     off;

# Specify a charset
    charset         utf-8;

# This tells Nginx to cache open file handles, "not found" errors, metadata about files and their permissions, etc.
# The upside of this is that Nginx can immediately begin sending data when a popular file is requested,
# and will also know to immediately send a 404 if a file is missing on disk, and so on.
# However, it also means that the server won't react immediately to changes on disk, which may be undesirable.
# In the below configuration, inactive files are released from the cache after 20 seconds, whereas
# active (recently requested) files are re-validated every 30 seconds.
# Descriptors will not be cached unless they are used at least 2 times within 20 seconds (the inactive time).
# A maximum of the 1000 most recently used file descriptors can be cached at any time.
# Production servers with stable file collections will definitely want to enable the cache.
    open_file_cache                         max=1000 inactive=20s;
    open_file_cache_valid                   30s;
    open_file_cache_min_uses                2;
    open_file_cache_errors                  on;


# Define the limits of the request rate
    limit_req_zone      $binary_remote_addr zone=ReqPerSec1:1m rate=1r/s;
    limit_req_zone      $binary_remote_addr zone=ReqPerSec10:1m rate=10r/s;
    limit_req_zone      $binary_remote_addr zone=ReqPerSec20:1m rate=20r/s;

# Define the limits of connections per ip
    limit_conn_zone     $binary_remote_addr zone=ConPerIP:5m;

# $bot_ua becomes "1" if User Agent contains any bot signatures
    map  $http_user_agent  $bot_ua
    {
        default     0;
        ~*(url|index|archive|spider|bot|crawl|\+http)   1;
        ''                                              1;
    }
# $bot_req becomes "1" if client requested one of the listed files
    map  $request_uri $bot_req
    {
        default      0;
        /robots.txt  1;
        /humans.txt  1;
    }

# $is_bot becomes 1 if at least one of $bot_req and $bot_ua was 1
    map  $bot_req$bot_ua  $is_bot
    {
        default     0;
        ~1          1;
    }
